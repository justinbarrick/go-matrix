// Code generated by go-swagger; DO NOT EDIT.

package room_participation

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"github.com/go-openapi/runtime"

	strfmt "github.com/go-openapi/strfmt"
)

// New creates a new room participation API client.
func New(transport runtime.ClientTransport, formats strfmt.Registry) *Client {
	return &Client{transport: transport, formats: formats}
}

/*
Client for room participation API
*/
type Client struct {
	transport runtime.ClientTransport
	formats   strfmt.Registry
}

/*
DefineFilter uploads a new filter

Uploads a new filter definition to the homeserver.
Returns a filter ID that may be used in future requests to
restrict which events are returned to the client.
*/
func (a *Client) DefineFilter(params *DefineFilterParams, authInfo runtime.ClientAuthInfoWriter) (*DefineFilterOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewDefineFilterParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "defineFilter",
		Method:             "POST",
		PathPattern:        "/_matrix/client/unstable/user/{userId}/filter",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &DefineFilterReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*DefineFilterOK), nil

}

/*
GetEventContext gets events and state around the specified event

This API returns a number of events that happened just before and
after the specified event. This allows clients to get the context
surrounding an event.
*/
func (a *Client) GetEventContext(params *GetEventContextParams, authInfo runtime.ClientAuthInfoWriter) (*GetEventContextOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetEventContextParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getEventContext",
		Method:             "GET",
		PathPattern:        "/_matrix/client/unstable/rooms/{roomId}/context/{eventId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetEventContextReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetEventContextOK), nil

}

/*
GetEvents listens on the event stream

This will listen for new events and return them to the caller. This will
block until an event is received, or until the ``timeout`` is reached.

This endpoint was deprecated in r0 of this specification. Clients
should instead call the |/sync|_ API with a ``since`` parameter. See
the `migration guide
<https://matrix.org/docs/guides/client-server-migrating-from-v1.html#deprecated-endpoints>`_.
*/
func (a *Client) GetEvents(params *GetEventsParams, authInfo runtime.ClientAuthInfoWriter) (*GetEventsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetEventsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getEvents",
		Method:             "GET",
		PathPattern:        "/_matrix/client/unstable/events",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetEventsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetEventsOK), nil

}

/*
GetFilter downloads a filter
*/
func (a *Client) GetFilter(params *GetFilterParams, authInfo runtime.ClientAuthInfoWriter) (*GetFilterOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetFilterParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getFilter",
		Method:             "GET",
		PathPattern:        "/_matrix/client/unstable/user/{userId}/filter/{filterId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetFilterReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetFilterOK), nil

}

/*
GetJoinedMembersByRoom gets the list of currently joined users and their profile data

This API returns a map of MXIDs to member info objects for members of the room. The current user must be in the room for it to work, unless it is an Application Service in which case any of the AS's users must be in the room. This API is primarily for Application Services and should be faster to respond than ``/members`` as it can be implemented more efficiently on the server.
*/
func (a *Client) GetJoinedMembersByRoom(params *GetJoinedMembersByRoomParams, authInfo runtime.ClientAuthInfoWriter) (*GetJoinedMembersByRoomOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetJoinedMembersByRoomParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getJoinedMembersByRoom",
		Method:             "GET",
		PathPattern:        "/_matrix/client/unstable/rooms/{roomId}/joined_members",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetJoinedMembersByRoomReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetJoinedMembersByRoomOK), nil

}

/*
GetMembersByRoom gets the m room member events for the room

Get the list of members for this room.
*/
func (a *Client) GetMembersByRoom(params *GetMembersByRoomParams, authInfo runtime.ClientAuthInfoWriter) (*GetMembersByRoomOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetMembersByRoomParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getMembersByRoom",
		Method:             "GET",
		PathPattern:        "/_matrix/client/unstable/rooms/{roomId}/members",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetMembersByRoomReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetMembersByRoomOK), nil

}

/*
GetOneEvent gets a single event by event ID

Get a single event based on ``event_id``. You must have permission to
retrieve this event e.g. by being a member in the room for this event.

This endpoint was deprecated in r0 of this specification. Clients
should instead call the |/rooms/{roomId}/event/{eventId}|_ API
or the |/rooms/{roomId}/context/{eventId}|_ API.
*/
func (a *Client) GetOneEvent(params *GetOneEventParams, authInfo runtime.ClientAuthInfoWriter) (*GetOneEventOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetOneEventParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getOneEvent",
		Method:             "GET",
		PathPattern:        "/_matrix/client/unstable/events/{eventId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetOneEventReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetOneEventOK), nil

}

/*
GetOneRoomEvent gets a single event by event ID

Get a single event based on ``roomId/eventId``. You must have permission to
retrieve this event e.g. by being a member in the room for this event.
*/
func (a *Client) GetOneRoomEvent(params *GetOneRoomEventParams, authInfo runtime.ClientAuthInfoWriter) (*GetOneRoomEventOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetOneRoomEventParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getOneRoomEvent",
		Method:             "GET",
		PathPattern:        "/_matrix/client/unstable/rooms/{roomId}/event/{eventId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetOneRoomEventReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetOneRoomEventOK), nil

}

/*
GetRoomEvents gets a list of events for this room

This API returns a list of message and state events for a room. It uses
pagination query parameters to paginate history in the room.
*/
func (a *Client) GetRoomEvents(params *GetRoomEventsParams, authInfo runtime.ClientAuthInfoWriter) (*GetRoomEventsOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRoomEventsParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getRoomEvents",
		Method:             "GET",
		PathPattern:        "/_matrix/client/unstable/rooms/{roomId}/messages",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetRoomEventsReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetRoomEventsOK), nil

}

/*
GetRoomState gets all state events in the current state of a room

Get the state events for the current state of a room.
*/
func (a *Client) GetRoomState(params *GetRoomStateParams, authInfo runtime.ClientAuthInfoWriter) (*GetRoomStateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRoomStateParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getRoomState",
		Method:             "GET",
		PathPattern:        "/_matrix/client/unstable/rooms/{roomId}/state",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetRoomStateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetRoomStateOK), nil

}

/*
GetRoomStateByType gets the state identified by the type with the empty state key

Looks up the contents of a state event in a room. If the user is
joined to the room then the state is taken from the current
state of the room. If the user has left the room then the state is
taken from the state of the room when they left.

This looks up the state event with the empty state key.
*/
func (a *Client) GetRoomStateByType(params *GetRoomStateByTypeParams, authInfo runtime.ClientAuthInfoWriter) (*GetRoomStateByTypeOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRoomStateByTypeParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getRoomStateByType",
		Method:             "GET",
		PathPattern:        "/_matrix/client/unstable/rooms/{roomId}/state/{eventType}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetRoomStateByTypeReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetRoomStateByTypeOK), nil

}

/*
GetRoomStateWithKey gets the state identified by the type and key

Looks up the contents of a state event in a room. If the user is
joined to the room then the state is taken from the current
state of the room. If the user has left the room then the state is
taken from the state of the room when they left.
*/
func (a *Client) GetRoomStateWithKey(params *GetRoomStateWithKeyParams, authInfo runtime.ClientAuthInfoWriter) (*GetRoomStateWithKeyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewGetRoomStateWithKeyParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "getRoomStateWithKey",
		Method:             "GET",
		PathPattern:        "/_matrix/client/unstable/rooms/{roomId}/state/{eventType}/{stateKey}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &GetRoomStateWithKeyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*GetRoomStateWithKeyOK), nil

}

/*
InitialSync gets the user s current state

This returns the full state for this user, with an optional limit on the
number of messages per room to return.

This endpoint was deprecated in r0 of this specification. Clients
should instead call the |/sync|_ API with no ``since`` parameter. See
the `migration guide
<https://matrix.org/docs/guides/client-server-migrating-from-v1.html#deprecated-endpoints>`_.
*/
func (a *Client) InitialSync(params *InitialSyncParams, authInfo runtime.ClientAuthInfoWriter) (*InitialSyncOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewInitialSyncParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "initialSync",
		Method:             "GET",
		PathPattern:        "/_matrix/client/unstable/initialSync",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &InitialSyncReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*InitialSyncOK), nil

}

/*
PostReceipt sends a receipt for the given event ID

This API updates the marker for the given receipt type to the event ID
specified.
*/
func (a *Client) PostReceipt(params *PostReceiptParams, authInfo runtime.ClientAuthInfoWriter) (*PostReceiptOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewPostReceiptParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "postReceipt",
		Method:             "POST",
		PathPattern:        "/_matrix/client/unstable/rooms/{roomId}/receipt/{receiptType}/{eventId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &PostReceiptReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*PostReceiptOK), nil

}

/*
RedactEvent strips all non integrity critical information out of an event

Strips all information out of an event which isn't critical to the
integrity of the server-side representation of the room.

This cannot be undone.

Users may redact their own events, and any user with a power level
greater than or equal to the `redact` power level of the room may
redact events there.
*/
func (a *Client) RedactEvent(params *RedactEventParams, authInfo runtime.ClientAuthInfoWriter) (*RedactEventOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRedactEventParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "redactEvent",
		Method:             "PUT",
		PathPattern:        "/_matrix/client/unstable/rooms/{roomId}/redact/{eventId}/{txnId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &RedactEventReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*RedactEventOK), nil

}

/*
RoomInitialSync snapshots the current state of a room and its most recent messages

Get a copy of the current state and the most recent messages in a room.

This endpoint was deprecated in r0 of this specification. There is no
direct replacement; the relevant information is returned by the
|/sync|_ API. See the `migration guide
<https://matrix.org/docs/guides/client-server-migrating-from-v1.html#deprecated-endpoints>`_.
*/
func (a *Client) RoomInitialSync(params *RoomInitialSyncParams, authInfo runtime.ClientAuthInfoWriter) (*RoomInitialSyncOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewRoomInitialSyncParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "roomInitialSync",
		Method:             "GET",
		PathPattern:        "/_matrix/client/unstable/rooms/{roomId}/initialSync",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &RoomInitialSyncReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*RoomInitialSyncOK), nil

}

/*
SendMessage sends a message event to the given room

This endpoint is used to send a message event to a room. Message events
allow access to historical events and pagination, making them suited
for "once-off" activity in a room.

The body of the request should be the content object of the event; the
fields in this object will vary depending on the type of event. See
`Room Events`_ for the m. event specification.
*/
func (a *Client) SendMessage(params *SendMessageParams, authInfo runtime.ClientAuthInfoWriter) (*SendMessageOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSendMessageParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "sendMessage",
		Method:             "PUT",
		PathPattern:        "/_matrix/client/unstable/rooms/{roomId}/send/{eventType}/{txnId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SendMessageReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*SendMessageOK), nil

}

/*
SetRoomState sends a state event to the given room

State events can be sent using this endpoint. This endpoint is
equivalent to calling `/rooms/{roomId}/state/{eventType}/{stateKey}`
with an empty `stateKey`. Previous state events with matching
`<roomId>` and `<eventType>`, and empty `<stateKey>`, will be overwritten.

Requests to this endpoint **cannot use transaction IDs**
like other ``PUT`` paths because they cannot be differentiated from the
``state_key``. Furthermore, ``POST`` is unsupported on state paths.

The body of the request should be the content object of the event; the
fields in this object will vary depending on the type of event. See
`Room Events`_ for the ``m.`` event specification.

*/
func (a *Client) SetRoomState(params *SetRoomStateParams, authInfo runtime.ClientAuthInfoWriter) (*SetRoomStateOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSetRoomStateParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "setRoomState",
		Method:             "PUT",
		PathPattern:        "/_matrix/client/unstable/rooms/{roomId}/state/{eventType}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SetRoomStateReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*SetRoomStateOK), nil

}

/*
SetRoomStateWithKey sends a state event to the given room

State events can be sent using this endpoint.  These events will be
overwritten if ``<room id>``, ``<event type>`` and ``<state key>`` all
match.

Requests to this endpoint **cannot use transaction IDs**
like other ``PUT`` paths because they cannot be differentiated from the
``state_key``. Furthermore, ``POST`` is unsupported on state paths.

The body of the request should be the content object of the event; the
fields in this object will vary depending on the type of event. See
`Room Events`_ for the ``m.`` event specification.

*/
func (a *Client) SetRoomStateWithKey(params *SetRoomStateWithKeyParams, authInfo runtime.ClientAuthInfoWriter) (*SetRoomStateWithKeyOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSetRoomStateWithKeyParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "setRoomStateWithKey",
		Method:             "PUT",
		PathPattern:        "/_matrix/client/unstable/rooms/{roomId}/state/{eventType}/{stateKey}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SetRoomStateWithKeyReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*SetRoomStateWithKeyOK), nil

}

/*
SetTyping informs the server that the user has started or stopped typing

This tells the server that the user is typing for the next N
milliseconds where N is the value specified in the ``timeout`` key.
Alternatively, if ``typing`` is ``false``, it tells the server that the
user has stopped typing.
*/
func (a *Client) SetTyping(params *SetTypingParams, authInfo runtime.ClientAuthInfoWriter) (*SetTypingOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSetTypingParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "setTyping",
		Method:             "PUT",
		PathPattern:        "/_matrix/client/unstable/rooms/{roomId}/typing/{userId}",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SetTypingReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*SetTypingOK), nil

}

/*
Sync synchronises the client s state and receive new messages

Synchronise the client's state with the latest state on the server.
Clients use this API when they first log in to get an initial snapshot
of the state on the server, and then continue to call this API to get
incremental deltas to the state, and to receive new messages.
*/
func (a *Client) Sync(params *SyncParams, authInfo runtime.ClientAuthInfoWriter) (*SyncOK, error) {
	// TODO: Validate the params before sending
	if params == nil {
		params = NewSyncParams()
	}

	result, err := a.transport.Submit(&runtime.ClientOperation{
		ID:                 "sync",
		Method:             "GET",
		PathPattern:        "/_matrix/client/unstable/sync",
		ProducesMediaTypes: []string{"application/json"},
		ConsumesMediaTypes: []string{"application/json"},
		Schemes:            []string{"https"},
		Params:             params,
		Reader:             &SyncReader{formats: a.formats},
		AuthInfo:           authInfo,
		Context:            params.Context,
		Client:             params.HTTPClient,
	})
	if err != nil {
		return nil, err
	}
	return result.(*SyncOK), nil

}

// SetTransport changes the transport on the client
func (a *Client) SetTransport(transport runtime.ClientTransport) {
	a.transport = transport
}
